# YouTube Upload Feature Specification

**Version**: 1.0
**Target Release**: v1.2.0 (after Auto-Edit completion)
**Status**: Planning
**Created**: 2025-11-06

---

## Overview

Direct upload to YouTube Shorts with automatic metadata generation, OAuth2 authentication, and upload progress tracking. Seamlessly publish auto-edited videos to YouTube without leaving the application.

**Core Value Proposition**: One-click publishing from LoLShorts to YouTube Shorts, with automatic title generation, tags, and thumbnail selection.

---

## User Workflow

### 1. Initial Setup (One-Time)
**Interface**: Settings page - YouTube integration section

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ YouTube Integration                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Status: âš ï¸ Not Connected                â”‚
â”‚                                         â”‚
â”‚ Connect your YouTube channel to upload â”‚
â”‚ Shorts directly from LoLShorts.        â”‚
â”‚                                         â”‚
â”‚ [ðŸ”— Connect YouTube Account]            â”‚
â”‚                                         â”‚
â”‚ â„¹ï¸ We only request permissions to:     â”‚
â”‚ â€¢ Upload videos                         â”‚
â”‚ â€¢ Manage your videos                    â”‚
â”‚ â€¢ View channel info                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**OAuth2 Flow**:
1. User clicks "Connect YouTube Account"
2. Opens browser to Google OAuth consent screen
3. User authorizes LoLShorts application
4. Redirect back to app with authorization code
5. Exchange code for access token + refresh token
6. Store tokens securely (Windows Credential Manager)

### 2. Upload from Editor
**Interface**: Upload button in video preview panel

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Video Preview                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ [Video Player]                          â”‚
â”‚                                         â”‚
â”‚ â–¶ï¸ final_edit_20251106_143045.mp4      â”‚
â”‚ Duration: 0:58 | Size: 45.2 MB         â”‚
â”‚                                         â”‚
â”‚ [ðŸ“¥ Export] [ðŸ“¤ Upload to YouTube]      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3. Upload Configuration Modal
**Interface**: Upload settings dialog

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Upload to YouTube Shorts                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Title (max 100 characters):                   â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ INSANE PENTAKILL! | Yasuo Highlight       â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚ âœ¨ Generated by AI | [Edit]                   â”‚
â”‚                                               â”‚
â”‚ Description:                                  â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ Amazing Yasuo pentakill in ranked!        â”‚ â”‚
â”‚ â”‚                                           â”‚ â”‚
â”‚ â”‚ Watch more League highlights on my        â”‚ â”‚
â”‚ â”‚ channel! Don't forget to subscribe!       â”‚ â”‚
â”‚ â”‚                                           â”‚ â”‚
â”‚ â”‚ #LeagueOfLegends #Yasuo #Pentakill        â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚ âœ¨ Generated by AI | [Edit]                   â”‚
â”‚                                               â”‚
â”‚ Tags:                                         â”‚
â”‚ ðŸ·ï¸ League of Legends  ðŸ·ï¸ Yasuo              â”‚
â”‚ ðŸ·ï¸ Pentakill  ðŸ·ï¸ Highlight  ðŸ·ï¸ Shorts      â”‚
â”‚ [+ Add Tag]                                   â”‚
â”‚                                               â”‚
â”‚ Privacy:                                      â”‚
â”‚ â— Public  â—‹ Unlisted  â—‹ Private              â”‚
â”‚                                               â”‚
â”‚ Category: [Gaming â–¼]                          â”‚
â”‚                                               â”‚
â”‚ Thumbnail:                                    â”‚
â”‚ [Auto] [Custom Upload]                        â”‚
â”‚ Preview: [thumbnail image]                    â”‚
â”‚                                               â”‚
â”‚ â˜‘ï¸ This video is made for kids: No           â”‚
â”‚ â˜‘ï¸ #Shorts (auto-detected for vertical video)â”‚
â”‚                                               â”‚
â”‚ [Cancel] [ðŸ“¤ Upload Now]                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4. Upload Progress
**Interface**: Progress tracking modal

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Uploading to YouTube                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Video: final_edit_20251106_143045.mp4         â”‚
â”‚                                               â”‚
â”‚ Progress: 67%                                 â”‚
â”‚ â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘                        â”‚
â”‚                                               â”‚
â”‚ Status: Uploading video...                    â”‚
â”‚ Uploaded: 30.2 MB / 45.2 MB                   â”‚
â”‚ Speed: 2.5 MB/s | Time remaining: 00:06       â”‚
â”‚                                               â”‚
â”‚ [Cancel Upload]                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5. Upload Complete
**Interface**: Success confirmation

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âœ… Upload Complete!                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Your video has been uploaded to YouTube.      â”‚
â”‚                                               â”‚
â”‚ Video: INSANE PENTAKILL! | Yasuo Highlight    â”‚
â”‚ URL: youtube.com/shorts/abc123XYZ             â”‚
â”‚                                               â”‚
â”‚ Processing: YouTube is processing your video. â”‚
â”‚ It may take a few minutes to appear in HD.    â”‚
â”‚                                               â”‚
â”‚ [ðŸ“‹ Copy Link] [ðŸŒ Open on YouTube] [Close]   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Technical Architecture

### Frontend Components (React/TypeScript)

#### New Components
```
src/components/upload/
â”œâ”€â”€ YouTubeConnect.tsx         # OAuth connection UI
â”œâ”€â”€ UploadModal.tsx            # Upload configuration dialog
â”œâ”€â”€ MetadataEditor.tsx         # Title/description/tags editor
â”œâ”€â”€ ThumbnailSelector.tsx      # Thumbnail selection/upload
â”œâ”€â”€ UploadProgress.tsx         # Progress bar + status
â””â”€â”€ UploadHistory.tsx          # Past uploads list

src/pages/Settings.tsx
- Add YouTube integration section
```

#### New Store
```typescript
// src/stores/youtubeStore.ts
interface YouTubeStore {
  // Connection state
  isConnected: boolean;
  channelInfo: YouTubeChannel | null;

  // Upload state
  currentUpload: UploadState | null;
  uploadHistory: UploadRecord[];

  // Actions
  connectYouTube: () => Promise<void>;
  disconnectYouTube: () => Promise<void>;
  uploadVideo: (config: UploadConfig) => Promise<string>;
  cancelUpload: (uploadId: string) => Promise<void>;
  getUploadHistory: () => Promise<UploadRecord[]>;
}
```

### Backend Implementation (Rust)

#### New Tauri Commands
```rust
// src-tauri/src/commands/youtube.rs

#[tauri::command]
async fn youtube_oauth_start(
    state: State<'_, AppState>
) -> Result<String, String> {
    // Generate OAuth URL with PKCE
    // Return authorization URL for browser
}

#[tauri::command]
async fn youtube_oauth_complete(
    code: String,
    state: State<'_, AppState>
) -> Result<YouTubeChannel, String> {
    // Exchange authorization code for tokens
    // Store tokens in Windows Credential Manager
    // Fetch and return channel info
}

#[tauri::command]
async fn youtube_disconnect(
    state: State<'_, AppState>
) -> Result<(), String> {
    // Revoke tokens
    // Clear stored credentials
}

#[tauri::command]
async fn youtube_upload_video(
    video_path: String,
    metadata: VideoMetadata,
    state: State<'_, AppState>
) -> Result<String, String> {
    // Upload video to YouTube
    // Return video ID
}

#[tauri::command]
async fn youtube_generate_metadata(
    video_path: String,
    game_events: Vec<GameEvent>,
    state: State<'_, AppState>
) -> Result<VideoMetadata, String> {
    // Generate title/description/tags based on events
    // Use AI or template-based generation
}

#[tauri::command]
async fn youtube_get_upload_progress(
    upload_id: String,
    state: State<'_, AppState>
) -> Result<UploadProgress, String> {
    // Return current upload progress
}
```

#### YouTube API Integration
```rust
// src-tauri/src/youtube/client.rs

use google_youtube3::{YouTube, oauth2};
use reqwest::multipart;

pub struct YouTubeClient {
    api_client: YouTube<hyper::Client>,
    oauth_client: oauth2::ApplicationSecret,
}

impl YouTubeClient {
    /// Initialize from stored credentials
    pub async fn from_credentials(
        access_token: String,
        refresh_token: String
    ) -> Result<Self> {
        // Initialize YouTube API client with tokens
    }

    /// Upload video with progress tracking
    pub async fn upload_video(
        &self,
        video_path: &Path,
        metadata: VideoMetadata,
        progress_callback: impl Fn(u64, u64)
    ) -> Result<String> {
        // Create video resource
        let video = Video {
            snippet: Some(Snippet {
                title: Some(metadata.title),
                description: Some(metadata.description),
                tags: Some(metadata.tags),
                category_id: Some("20".to_string()), // Gaming
                default_language: Some("en".to_string()),
                ..Default::default()
            }),
            status: Some(VideoStatus {
                privacy_status: Some(metadata.privacy.to_string()),
                made_for_kids: Some(false),
                self_declared_made_for_kids: Some(false),
                ..Default::default()
            }),
            ..Default::default()
        };

        // Upload video file with progress tracking
        let file = tokio::fs::File::open(video_path).await?;
        let file_size = file.metadata().await?.len();

        // Use resumable upload for progress tracking
        let upload_uri = self.start_resumable_upload(&video).await?;
        let video_id = self.upload_chunks(upload_uri, file, file_size, progress_callback).await?;

        Ok(video_id)
    }

    /// Refresh access token using refresh token
    async fn refresh_access_token(&mut self) -> Result<()> {
        // Use refresh token to get new access token
        // Update stored credentials
    }
}
```

#### OAuth2 Flow Implementation
```rust
// src-tauri/src/youtube/oauth.rs

use oauth2::{
    AuthUrl, ClientId, ClientSecret, CsrfToken, PkceCodeChallenge,
    RedirectUrl, Scope, TokenUrl
};

pub struct YouTubeOAuth {
    client: oauth2::basic::BasicClient,
}

impl YouTubeOAuth {
    pub fn new() -> Result<Self> {
        // Load client ID/secret from environment or config
        let client_id = ClientId::new(
            std::env::var("YOUTUBE_CLIENT_ID")?
        );
        let client_secret = ClientSecret::new(
            std::env::var("YOUTUBE_CLIENT_SECRET")?
        );

        let auth_url = AuthUrl::new(
            "https://accounts.google.com/o/oauth2/v2/auth".to_string()
        )?;
        let token_url = TokenUrl::new(
            "https://oauth2.googleapis.com/token".to_string()
        )?;

        let client = oauth2::basic::BasicClient::new(
            client_id,
            Some(client_secret),
            auth_url,
            Some(token_url)
        )
        .set_redirect_uri(RedirectUrl::new(
            "http://localhost:9090/oauth/callback".to_string()
        )?);

        Ok(Self { client })
    }

    /// Generate authorization URL with PKCE
    pub fn generate_auth_url(&self) -> (String, CsrfToken, PkceCodeChallenge) {
        let (pkce_challenge, pkce_verifier) = PkceCodeChallenge::new_random_sha256();

        let (auth_url, csrf_token) = self.client
            .authorize_url(CsrfToken::new_random)
            .add_scope(Scope::new("https://www.googleapis.com/auth/youtube.upload".to_string()))
            .add_scope(Scope::new("https://www.googleapis.com/auth/youtube".to_string()))
            .set_pkce_challenge(pkce_challenge)
            .url();

        (auth_url.to_string(), csrf_token, pkce_verifier)
    }

    /// Exchange authorization code for tokens
    pub async fn exchange_code(
        &self,
        code: String,
        pkce_verifier: PkceCodeVerifier
    ) -> Result<TokenResponse> {
        let token_result = self.client
            .exchange_code(AuthorizationCode::new(code))
            .set_pkce_verifier(pkce_verifier)
            .request_async(oauth2::reqwest::async_http_client)
            .await?;

        Ok(TokenResponse {
            access_token: token_result.access_token().secret().clone(),
            refresh_token: token_result.refresh_token()
                .map(|t| t.secret().clone()),
            expires_in: token_result.expires_in()
                .map(|d| d.as_secs()),
        })
    }
}
```

#### Secure Token Storage
```rust
// src-tauri/src/youtube/credentials.rs

use windows::Security::Credentials::PasswordVault;

pub struct YouTubeCredentials;

impl YouTubeCredentials {
    const RESOURCE: &'static str = "LoLShorts_YouTube";

    /// Store tokens in Windows Credential Manager
    pub fn store_tokens(
        access_token: &str,
        refresh_token: &str
    ) -> Result<()> {
        let vault = PasswordVault::new()?;

        // Store access token
        let access_cred = PasswordCredential::new(
            Self::RESOURCE,
            "access_token",
            access_token
        )?;
        vault.Add(&access_cred)?;

        // Store refresh token
        let refresh_cred = PasswordCredential::new(
            Self::RESOURCE,
            "refresh_token",
            refresh_token
        )?;
        vault.Add(&refresh_cred)?;

        Ok(())
    }

    /// Retrieve tokens from Windows Credential Manager
    pub fn load_tokens() -> Result<(String, String)> {
        let vault = PasswordVault::new()?;

        let access_cred = vault.Retrieve(Self::RESOURCE, "access_token")?;
        access_cred.RetrievePassword()?;
        let access_token = access_cred.Password()?.to_string();

        let refresh_cred = vault.Retrieve(Self::RESOURCE, "refresh_token")?;
        refresh_cred.RetrievePassword()?;
        let refresh_token = refresh_cred.Password()?.to_string();

        Ok((access_token, refresh_token))
    }

    /// Delete stored tokens
    pub fn delete_tokens() -> Result<()> {
        let vault = PasswordVault::new()?;

        vault.Remove(&PasswordCredential::new(
            Self::RESOURCE,
            "access_token",
            ""
        )?)?;

        vault.Remove(&PasswordCredential::new(
            Self::RESOURCE,
            "refresh_token",
            ""
        )?)?;

        Ok(())
    }
}
```

---

## Data Models

### TypeScript Models
```typescript
interface YouTubeChannel {
  id: string;
  title: string;
  customUrl?: string;
  thumbnailUrl: string;
  subscriberCount?: number;
}

interface VideoMetadata {
  title: string;              // Max 100 characters
  description: string;        // Max 5000 characters
  tags: string[];            // Max 500 characters total
  privacy: 'public' | 'unlisted' | 'private';
  categoryId: string;        // "20" = Gaming
  madeForKids: boolean;
  thumbnail?: File;
}

interface UploadConfig {
  videoPath: string;
  metadata: VideoMetadata;
}

interface UploadState {
  uploadId: string;
  videoPath: string;
  metadata: VideoMetadata;
  status: 'preparing' | 'uploading' | 'processing' | 'completed' | 'failed';
  progress: number;          // 0-100
  uploadedBytes: number;
  totalBytes: number;
  speed: number;             // bytes per second
  error?: string;
}

interface UploadRecord {
  videoId: string;
  title: string;
  uploadedAt: Date;
  url: string;
  thumbnailUrl: string;
  viewCount?: number;
  likeCount?: number;
}
```

### Rust Models
```rust
// src-tauri/src/youtube/models.rs

#[derive(Debug, Serialize, Deserialize)]
pub struct YouTubeChannel {
    pub id: String,
    pub title: String,
    pub custom_url: Option<String>,
    pub thumbnail_url: String,
    pub subscriber_count: Option<u64>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct VideoMetadata {
    pub title: String,
    pub description: String,
    pub tags: Vec<String>,
    pub privacy: PrivacyStatus,
    pub category_id: String,
    pub made_for_kids: bool,
    pub thumbnail_path: Option<PathBuf>,
}

#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum PrivacyStatus {
    Public,
    Unlisted,
    Private,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct UploadProgress {
    pub upload_id: String,
    pub status: UploadStatus,
    pub progress: f64,
    pub uploaded_bytes: u64,
    pub total_bytes: u64,
    pub speed: u64,
    pub error: Option<String>,
}

#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum UploadStatus {
    Preparing,
    Uploading,
    Processing,
    Completed,
    Failed,
}
```

---

## AI-Powered Metadata Generation

### Title Generation Algorithm
```rust
// src-tauri/src/youtube/metadata_generator.rs

pub struct MetadataGenerator;

impl MetadataGenerator {
    /// Generate video title from game events
    pub fn generate_title(events: &[GameEvent], champion: &str) -> String {
        // Prioritize most impressive event
        let highlight = self.get_top_event(events);

        match highlight.event_type {
            EventType::Pentakill => {
                format!("INSANE PENTAKILL! | {} Highlight", champion)
            }
            EventType::Quadrakill => {
                format!("QUADRAKILL! | {} Montage", champion)
            }
            EventType::BaronSteal => {
                format!("BARON STEAL! | {} Clutch Play", champion)
            }
            EventType::DragonSteal => {
                format!("DRAGON STEAL! | {} Outplay", champion)
            }
            _ => {
                format!("{} Highlight | League of Legends", champion)
            }
        }
    }

    /// Generate video description
    pub fn generate_description(
        events: &[GameEvent],
        champion: &str,
        game_duration: f64
    ) -> String {
        let mut desc = String::new();

        // Main description
        desc.push_str(&format!(
            "Amazing {} plays from a ranked game!\n\n",
            champion
        ));

        // Timestamp highlights
        desc.push_str("Timestamps:\n");
        for (i, event) in events.iter().take(5).enumerate() {
            let timestamp = self.format_timestamp(event.event_time);
            desc.push_str(&format!(
                "{}. {} - {}\n",
                i + 1,
                timestamp,
                event.event_name
            ));
        }

        // Call-to-action
        desc.push_str("\n");
        desc.push_str("Watch more League highlights on my channel!\n");
        desc.push_str("Don't forget to subscribe for more epic plays!\n\n");

        // Tags
        desc.push_str(&self.generate_hashtags(events, champion));

        desc
    }

    /// Generate tags
    pub fn generate_tags(events: &[GameEvent], champion: &str) -> Vec<String> {
        let mut tags = vec![
            "League of Legends".to_string(),
            "LoL".to_string(),
            champion.to_string(),
            "Highlight".to_string(),
            "Shorts".to_string(),
        ];

        // Add event-specific tags
        for event in events.iter().take(3) {
            match event.event_type {
                EventType::Pentakill => tags.push("Pentakill".to_string()),
                EventType::Quadrakill => tags.push("Quadrakill".to_string()),
                EventType::BaronSteal => tags.push("Baron Steal".to_string()),
                _ => {}
            }
        }

        // Deduplicate and limit to 10 tags
        tags.dedup();
        tags.truncate(10);

        tags
    }
}
```

---

## Upload Progress Tracking

### Chunked Upload with Progress
```rust
// src-tauri/src/youtube/uploader.rs

impl YouTubeClient {
    /// Upload video in chunks with progress tracking
    async fn upload_chunks(
        &self,
        upload_uri: String,
        mut file: tokio::fs::File,
        file_size: u64,
        progress_callback: impl Fn(u64, u64)
    ) -> Result<String> {
        const CHUNK_SIZE: usize = 5 * 1024 * 1024; // 5MB chunks

        let mut uploaded = 0u64;
        let mut buffer = vec![0u8; CHUNK_SIZE];

        loop {
            let bytes_read = file.read(&mut buffer).await?;
            if bytes_read == 0 {
                break; // EOF
            }

            uploaded += bytes_read as u64;

            // Upload chunk
            let chunk_end = uploaded - 1;
            let response = self.client
                .put(&upload_uri)
                .header("Content-Length", bytes_read.to_string())
                .header(
                    "Content-Range",
                    format!("bytes {}-{}/{}", uploaded - bytes_read as u64, chunk_end, file_size)
                )
                .body(buffer[..bytes_read].to_vec())
                .send()
                .await?;

            // Emit progress
            progress_callback(uploaded, file_size);

            // Check if upload complete
            if response.status() == 200 || response.status() == 201 {
                let video_response: VideoResponse = response.json().await?;
                return Ok(video_response.id);
            }
        }

        Err(AppError::Upload("Upload incomplete".to_string()))
    }
}
```

### Frontend Progress Display
```typescript
// src/components/upload/UploadProgress.tsx

export function UploadProgress({ uploadId }: { uploadId: string }) {
  const [progress, setProgress] = useState<UploadState | null>(null);

  useEffect(() => {
    const interval = setInterval(async () => {
      const current = await invoke<UploadState>(
        'youtube_get_upload_progress',
        { uploadId }
      );
      setProgress(current);

      if (current.status === 'completed' || current.status === 'failed') {
        clearInterval(interval);
      }
    }, 1000);

    return () => clearInterval(interval);
  }, [uploadId]);

  if (!progress) return <LoadingSpinner />;

  const speedMbps = (progress.speed / 1024 / 1024).toFixed(1);
  const remaining = (progress.totalBytes - progress.uploadedBytes) / progress.speed;
  const remainingFormatted = formatDuration(remaining);

  return (
    <div className="space-y-4">
      <Progress value={progress.progress} />
      <div className="flex justify-between text-sm">
        <span>{progress.progress.toFixed(0)}%</span>
        <span>{speedMbps} MB/s | {remainingFormatted} remaining</span>
      </div>
      <p className="text-muted-foreground">{getStatusMessage(progress.status)}</p>
    </div>
  );
}
```

---

## TikTok Upload Integration (Future)

**Note**: TikTok API access requires business verification. Plan for v1.3.0 after YouTube is stable.

### TikTok API Differences
- **Authentication**: OAuth2 similar to YouTube
- **Video Format**: Same 9:16 vertical format (compatible)
- **Max Duration**: 10 minutes (vs YouTube Shorts 60s)
- **API Endpoint**: `https://open-api.tiktok.com/share/video/upload/`
- **Required Scopes**: `video.upload`, `user.info.basic`

### Shared Upload Infrastructure
```rust
// Trait-based design for multi-platform uploads
pub trait VideoUploadPlatform {
    async fn authenticate(&mut self) -> Result<()>;
    async fn upload_video(&self, config: UploadConfig) -> Result<String>;
    async fn get_upload_progress(&self, id: &str) -> Result<UploadProgress>;
}

// Implementations
impl VideoUploadPlatform for YouTubeClient { /* ... */ }
impl VideoUploadPlatform for TikTokClient { /* ... */ } // v1.3.0
```

---

## Implementation Phases

### Phase 1: OAuth Authentication (Week 1)
**Priority**: Critical
**Dependencies**: None

**Tasks**:
- [ ] Setup Google Cloud Console project
- [ ] Obtain OAuth2 client credentials
- [ ] Implement OAuth flow (authorization URL generation)
- [ ] Create callback server (localhost:9090)
- [ ] Implement token exchange
- [ ] Implement Windows Credential Manager storage
- [ ] Create YouTubeConnect component
- [ ] Add connection status to Settings page

**Acceptance Criteria**:
- Users can connect YouTube account
- Tokens stored securely in Windows Credential Manager
- Connection persists across app restarts
- Disconnect functionality works

### Phase 2: Video Upload Core (Week 2-3)
**Priority**: Critical
**Dependencies**: Phase 1

**Tasks**:
- [ ] Integrate google-youtube3 Rust crate
- [ ] Implement YouTubeClient with upload method
- [ ] Implement resumable upload with chunking
- [ ] Add progress tracking system
- [ ] Create UploadModal component
- [ ] Create UploadProgress component
- [ ] Add "Upload to YouTube" button to Editor

**Acceptance Criteria**:
- Videos upload successfully to YouTube
- Progress tracking updates in real-time
- Upload can be cancelled
- Errors handled gracefully

### Phase 3: Metadata Generation (Week 4)
**Priority**: High
**Dependencies**: Phase 2

**Tasks**:
- [ ] Implement title generation algorithm
- [ ] Implement description generation
- [ ] Implement tag generation
- [ ] Create MetadataEditor component
- [ ] Add AI-powered suggestions (optional)
- [ ] Implement metadata preview

**Acceptance Criteria**:
- Titles accurately reflect video content
- Descriptions include timestamps
- Tags are relevant and optimized
- Users can edit generated metadata

### Phase 4: Thumbnail Management (Week 5)
**Priority**: Medium
**Dependencies**: Phase 2

**Tasks**:
- [ ] Auto-extract thumbnail from video (middle frame)
- [ ] Implement custom thumbnail upload
- [ ] Create ThumbnailSelector component
- [ ] Add thumbnail preview
- [ ] Implement thumbnail upload to YouTube

**Acceptance Criteria**:
- Auto-generated thumbnail looks good
- Custom thumbnails can be uploaded
- Thumbnail preview matches final result

### Phase 5: Upload History & Management (Week 6)
**Priority**: Medium
**Dependencies**: Phase 2

**Tasks**:
- [ ] Create upload history database table
- [ ] Implement UploadHistory component
- [ ] Fetch video stats from YouTube API (views, likes)
- [ ] Add "Open on YouTube" links
- [ ] Implement upload retry functionality

**Acceptance Criteria**:
- Upload history displays correctly
- Stats update when refreshed
- Failed uploads can be retried

### Phase 6: Testing & Polish (Week 7)
**Priority**: Critical
**Dependencies**: All previous phases

**Tasks**:
- [ ] E2E testing of complete upload flow
- [ ] Error handling for network failures
- [ ] Error handling for quota limits
- [ ] Token refresh testing
- [ ] Performance optimization
- [ ] UI/UX polish

**Acceptance Criteria**:
- All error cases handled gracefully
- Upload success rate >95%
- Average upload time <60s for 50MB video
- UI is intuitive and responsive

---

## Performance Targets

| Metric | Target | Measurement |
|--------|--------|-------------|
| **Upload Speed** | >2 MB/s | Average throughput |
| **Token Refresh** | <2 seconds | Time to refresh expired token |
| **Metadata Generation** | <1 second | Algorithm execution time |
| **Upload Success Rate** | >95% | Successful uploads / total attempts |
| **Max Video Size** | 256 MB | YouTube Shorts limit |

---

## Error Handling

### Common Errors
```rust
#[derive(Debug, Error)]
pub enum YouTubeError {
    #[error("Not authenticated. Please connect your YouTube account.")]
    NotAuthenticated,

    #[error("Token expired. Refreshing...")]
    TokenExpired,

    #[error("Upload quota exceeded. Try again tomorrow.")]
    QuotaExceeded,

    #[error("Video too large. Max size: 256 MB")]
    VideoTooLarge,

    #[error("Network error: {0}")]
    NetworkError(String),

    #[error("YouTube API error: {0}")]
    ApiError(String),
}
```

### User-Facing Error Messages
```typescript
function getErrorMessage(error: string): string {
  if (error.includes('NotAuthenticated')) {
    return 'Please connect your YouTube account in Settings.';
  }
  if (error.includes('QuotaExceeded')) {
    return 'YouTube upload quota exceeded. Please try again tomorrow.';
  }
  if (error.includes('VideoTooLarge')) {
    return 'Video file is too large. Please reduce quality or duration.';
  }
  if (error.includes('NetworkError')) {
    return 'Network error. Please check your internet connection.';
  }
  return 'Upload failed. Please try again.';
}
```

---

## Security Considerations

### OAuth Best Practices
- **PKCE Flow**: Use Proof Key for Code Exchange to prevent authorization code interception
- **State Parameter**: Validate CSRF token on OAuth callback
- **Token Storage**: Store in Windows Credential Manager (encrypted at rest)
- **Token Refresh**: Automatically refresh expired tokens
- **Revocation**: Support token revocation on disconnect

### API Key Security
- **Never Hardcode**: Store client ID/secret in environment variables
- **Rotate Keys**: Rotate OAuth credentials periodically
- **Scope Minimization**: Only request necessary scopes
- **Audit Logging**: Log all upload attempts for debugging

### Rate Limiting
- **YouTube API Quota**: 10,000 units/day (1 upload = 1,600 units = ~6 uploads/day)
- **Backoff Strategy**: Exponential backoff on 429 errors
- **User Notification**: Warn users when approaching quota limits

---

## Testing Strategy

### Unit Tests
```rust
#[cfg(test)]
mod tests {
    #[test]
    fn test_title_generation() {
        let events = vec![
            GameEvent { event_type: EventType::Pentakill, ... }
        ];
        let title = MetadataGenerator::generate_title(&events, "Yasuo");

        assert!(title.contains("PENTAKILL"));
        assert!(title.contains("Yasuo"));
        assert!(title.len() <= 100); // YouTube limit
    }

    #[test]
    fn test_tag_generation() {
        let events = vec![/* test events */];
        let tags = MetadataGenerator::generate_tags(&events, "Yasuo");

        assert!(tags.contains(&"League of Legends".to_string()));
        assert!(tags.len() <= 10); // Reasonable limit
    }
}
```

### Integration Tests
```typescript
// tests/e2e/youtube-upload.spec.ts

test('complete upload flow', async ({ page }) => {
  // Prerequisite: Mock OAuth (use test account)

  // Navigate to editor
  await page.goto('http://localhost:1420/editor');

  // Select video
  await page.click('[data-testid="video-item-12345"]');

  // Click upload
  await page.click('[data-testid="upload-youtube-button"]');

  // Verify metadata generation
  const title = await page.inputValue('[data-testid="video-title"]');
  expect(title).toBeTruthy();
  expect(title.length).toBeLessThanOrEqual(100);

  // Start upload
  await page.click('[data-testid="upload-now-button"]');

  // Wait for completion
  await expect(page.locator('[data-testid="upload-complete"]'))
    .toBeVisible({ timeout: 120000 }); // 2 minutes max

  // Verify success
  const videoUrl = await page.textContent('[data-testid="video-url"]');
  expect(videoUrl).toContain('youtube.com/shorts/');
});
```

---

## User Documentation

### Quick Start Guide
```markdown
# Upload to YouTube

1. **Connect Account** (one-time setup)
   - Go to Settings â†’ YouTube Integration
   - Click "Connect YouTube Account"
   - Authorize LoLShorts in your browser
   - Done! You're connected.

2. **Upload Video**
   - Open your video in the Editor
   - Click "Upload to YouTube" button
   - Review auto-generated title and description
   - Adjust privacy settings if needed
   - Click "Upload Now"

3. **Track Progress**
   - Watch the upload progress bar
   - Wait for "Upload Complete" message
   - Click "Open on YouTube" to view your video

**Tips**:
- YouTube processes videos after upload. HD quality may take a few minutes.
- Your video will automatically be tagged as #Shorts (for vertical videos).
- You can upload ~6 videos per day due to YouTube API quotas.
```

---

## YouTube API Quotas

### Daily Quota Breakdown
- **Total Daily Quota**: 10,000 units
- **Per Upload Cost**: ~1,600 units
  - `videos.insert`: 1,600 units
  - `thumbnails.set`: 50 units (optional)
- **Maximum Uploads per Day**: ~6 videos

### Quota Management Strategy
- Display remaining quota in UI
- Warn users when <2 uploads remaining
- Cache channel info (100 units saved per session)
- Use batch requests where possible

---

## Dependencies

### Rust Crates
```toml
[dependencies]
# YouTube API
google-youtube3 = "5.0"
hyper = "0.14"
hyper-rustls = "0.24"

# OAuth2
oauth2 = "4.4"

# Async HTTP
reqwest = { version = "0.11", features = ["multipart", "stream"] }
tokio = { version = "1", features = ["full"] }

# Credentials storage (Windows)
windows = { version = "0.51", features = ["Security_Credentials"] }
```

### Frontend Dependencies
```json
{
  "dependencies": {
    "@tanstack/react-query": "^5.0.0"
  }
}
```

---

## Environment Variables

### Required for Development
```env
# YouTube OAuth Credentials (from Google Cloud Console)
YOUTUBE_CLIENT_ID=your_client_id.apps.googleusercontent.com
YOUTUBE_CLIENT_SECRET=your_client_secret

# Optional: API Key for read-only operations (stats, channel info)
YOUTUBE_API_KEY=your_api_key
```

### Setup Instructions
1. Go to [Google Cloud Console](https://console.cloud.google.com/)
2. Create new project: "LoLShorts"
3. Enable YouTube Data API v3
4. Create OAuth 2.0 credentials (Desktop App)
5. Add authorized redirect URI: `http://localhost:9090/oauth/callback`
6. Copy client ID and secret to `.env`

---

## Future Enhancements (Post-v1.2.0)

### v1.3.0: TikTok Integration
- Add TikTok OAuth authentication
- Implement TikTok upload API integration
- Support simultaneous YouTube + TikTok upload

### v1.4.0: Advanced Features
- **Scheduled Uploads**: Queue videos for specific publish times
- **Multi-Account**: Support multiple YouTube channels
- **Analytics Dashboard**: View video performance stats
- **A/B Testing**: Upload multiple versions with different titles/thumbnails

### v2.0.0: Cloud Upload
- **Server-Side Upload**: Offload uploads to cloud for faster completion
- **Mobile Upload**: Upload from mobile companion app
- **Batch Upload**: Upload multiple videos simultaneously

---

**End of Specification**
